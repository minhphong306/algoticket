#pragma version 9

// This TEAL was generated by TEALScript v0.59.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

// createApplication()void
abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

createApplication:
	proto 0 0

	// contracts/nft_marketplace.algo.ts:44
	// this.eventIndex.value = 0
	byte 0x6576656e74496e646578 // "eventIndex"
	int 0
	app_global_put

	// contracts/nft_marketplace.algo.ts:45
	// this.orderIndex.value = 0
	byte 0x6f72646572496e646578 // "orderIndex"
	int 0
	app_global_put

	// contracts/nft_marketplace.algo.ts:46
	// this.nftIndex.value = 0
	byte 0x6e6674496e646578 // "nftIndex"
	int 0
	app_global_put
	retsub

// getApplicationAddress()address
abi_route_getApplicationAddress:
	// execute getApplicationAddress()address
	callsub getApplicationAddress
	int 1
	return

getApplicationAddress:
	proto 0 0

	// contracts/nft_marketplace.algo.ts:50
	// return this.app.address;
	byte 0x151f7c75
	global CurrentApplicationAddress
	concat
	log
	retsub

// createEvent(uint64,uint64,uint64,uint64,uint64,uint64,string)void
abi_route_createEvent:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// nft3price: uint64
	txna ApplicationArgs 7
	btoi

	// nft2price: uint64
	txna ApplicationArgs 6
	btoi

	// nft1price: uint64
	txna ApplicationArgs 5
	btoi

	// nft3: uint64
	txna ApplicationArgs 4
	btoi

	// nft2: uint64
	txna ApplicationArgs 3
	btoi

	// nft1: uint64
	txna ApplicationArgs 2
	btoi

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createEvent(uint64,uint64,uint64,uint64,uint64,uint64,string)void
	callsub createEvent
	int 1
	return

createEvent:
	proto 8 0

	// contracts/nft_marketplace.algo.ts:62
	// temp: eventData = {
	//       name: name,
	//       nft1: nft1,
	//       nft2: nft2,
	//       nft3: nft3,
	//       nft1_price: nft1price,
	//       nft2_price: nft2price,
	//       nft3_price: nft3price,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0032 // initial head offset
	frame_dig -1 // name: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -2 // nft1: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -3 // nft2: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -4 // nft3: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -5 // nft1price: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -6 // nft2price: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -7 // nft3price: uint64
	itob
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury -8 // temp: eventData

	// contracts/nft_marketplace.algo.ts:72
	// this.event(this.eventIndex.value).value = temp
	byte 0x6576656e74496e646578 // "eventIndex"
	app_global_get
	itob
	dup
	box_del
	pop
	frame_dig -8 // temp: eventData
	box_put

	// contracts/nft_marketplace.algo.ts:73
	// this.eventIndex.value = this.eventIndex.value + 1
	byte 0x6576656e74496e646578 // "eventIndex"
	byte 0x6576656e74496e646578 // "eventIndex"
	app_global_get
	int 1
	+
	app_global_put
	retsub

// mintNFT(string,string)uint64
//
// // mintNFT
abi_route_mintNFT:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// url: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute mintNFT(string,string)uint64
	callsub mintNFT
	int 1
	return

mintNFT:
	proto 3 0

	// contracts/nft_marketplace.algo.ts:78
	// nftTicket = sendAssetCreation({
	//       configAssetTotal: 1,
	//       configAssetName: name,
	//       configAssetURL: url,
	//     })
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts/nft_marketplace.algo.ts:79
	// configAssetTotal: 1
	int 1
	itxn_field ConfigAssetTotal

	// contracts/nft_marketplace.algo.ts:80
	// configAssetName: name
	frame_dig -1 // name: bytes
	itxn_field ConfigAssetName

	// contracts/nft_marketplace.algo.ts:81
	// configAssetURL: url
	frame_dig -2 // url: bytes
	itxn_field ConfigAssetURL

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury -3 // nftTicket: asset

	// contracts/nft_marketplace.algo.ts:83
	// return nftTicket;
	frame_dig -3 // nftTicket: asset
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// mapNFTdata(uint64,uint64,asset)void
abi_route_mapNFTdata:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// nftType: uint64
	txna ApplicationArgs 3
	btoi

	// eventId: uint64
	txna ApplicationArgs 2
	btoi

	// nft: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute mapNFTdata(uint64,uint64,asset)void
	callsub mapNFTdata
	int 1
	return

mapNFTdata:
	proto 4 0

	// contracts/nft_marketplace.algo.ts:88
	// temp: nftData = {
	//       eventId: eventId,
	//       nftType: nftType,
	//       nftAsset: nft,
	//     }
	frame_dig -2 // eventId: uint64
	itob
	frame_dig -3 // nftType: uint64
	itob
	concat
	frame_dig -1 // nft: asset
	itob
	concat
	frame_bury -4 // temp: nftData

	// contracts/nft_marketplace.algo.ts:94
	// this.nftDataMap(this.nftIndex.value).value = temp
	byte 0x6e // "n"
	byte 0x6e6674496e646578 // "nftIndex"
	app_global_get
	itob
	concat
	frame_dig -4 // temp: nftData
	box_put

	// contracts/nft_marketplace.algo.ts:95
	// this.nftIndex.value = this.nftIndex.value + 1
	byte 0x6e6674496e646578 // "nftIndex"
	byte 0x6e6674496e646578 // "nftIndex"
	app_global_get
	int 1
	+
	app_global_put
	retsub

// buyNFTFromEvent(asset,pay)void
abi_route_buyNFTFromEvent:
	// nft: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// payment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute buyNFTFromEvent(asset,pay)void
	callsub buyNFTFromEvent
	int 1
	return

buyNFTFromEvent:
	proto 2 0

	// contracts/nft_marketplace.algo.ts:99
	// sendAssetTransfer({
	//       xferAsset: nft,
	//       assetReceiver: this.txn.sender,
	//       assetAmount: 1,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/nft_marketplace.algo.ts:100
	// xferAsset: nft
	frame_dig -2 // nft: asset
	itxn_field XferAsset

	// contracts/nft_marketplace.algo.ts:101
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/nft_marketplace.algo.ts:102
	// assetAmount: 1
	int 1
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// listingNFT(axfer,uint64,asset)void
abi_route_listingNFT:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// axfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// price: uint64
	txna ApplicationArgs 2
	btoi

	// nft: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute listingNFT(axfer,uint64,asset)void
	callsub listingNFT
	int 1
	return

listingNFT:
	proto 4 0

	// contracts/nft_marketplace.algo.ts:108
	// verifyTxn(axfer, { assetReceiver: this.app.address })
	// verify assetReceiver
	frame_dig -3 // axfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/nft_marketplace.algo.ts:111
	// temp: orderData = {
	//       owner: this.txn.sender,
	//       price: price,
	//       nft: nft,
	//       status: 0,
	//     }
	txn Sender
	frame_dig -2 // price: uint64
	itob
	concat
	frame_dig -1 // nft: asset
	itob
	concat
	byte 0x0000000000000000
	concat
	frame_bury -4 // temp: orderData

	// contracts/nft_marketplace.algo.ts:118
	// this.order(this.orderIndex.value).value = temp
	byte 0x6f // "o"
	byte 0x6f72646572496e646578 // "orderIndex"
	app_global_get
	itob
	concat
	frame_dig -4 // temp: orderData
	box_put

	// contracts/nft_marketplace.algo.ts:119
	// this.orderIndex.value = this.orderIndex.value + 1
	byte 0x6f72646572496e646578 // "orderIndex"
	byte 0x6f72646572496e646578 // "orderIndex"
	app_global_get
	int 1
	+
	app_global_put
	retsub

// unListingNFT(asset,uint64)void
abi_route_unListingNFT:
	// nft: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute unListingNFT(asset,uint64)void
	callsub unListingNFT
	int 1
	return

unListingNFT:
	proto 2 0

	// contracts/nft_marketplace.algo.ts:129
	// this.order(orderId).value.status = 1
	int 48
	byte 0x0000000000000001
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/nft_marketplace.algo.ts:132
	// sendAssetTransfer({
	//       xferAsset: nft,
	//       assetReceiver: this.txn.sender,
	//       assetAmount: 1,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/nft_marketplace.algo.ts:133
	// xferAsset: nft
	frame_dig -2 // nft: asset
	itxn_field XferAsset

	// contracts/nft_marketplace.algo.ts:134
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/nft_marketplace.algo.ts:135
	// assetAmount: 1
	int 1
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// buyNFTFromMarketplace(asset,pay,uint64)void
abi_route_buyNFTFromMarketplace:
	// nft: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// payment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute buyNFTFromMarketplace(asset,pay,uint64)void
	callsub buyNFTFromMarketplace
	int 1
	return

buyNFTFromMarketplace:
	proto 3 0

	// contracts/nft_marketplace.algo.ts:150
	// sendAssetTransfer({
	//       xferAsset: nft,
	//       assetReceiver: this.txn.sender,
	//       assetAmount: 1,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/nft_marketplace.algo.ts:151
	// xferAsset: nft
	frame_dig -3 // nft: asset
	itxn_field XferAsset

	// contracts/nft_marketplace.algo.ts:152
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/nft_marketplace.algo.ts:153
	// assetAmount: 1
	int 1
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// getEventName(uint64)string
abi_route_getEventName:
	// eventId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getEventName(uint64)string
	callsub getEventName
	int 1
	return

getEventName:
	proto 1 0

	// contracts/nft_marketplace.algo.ts:158
	// return this.event(eventId).value.name;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	int 0
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getNFTAmountLeft(uint64,uint64)uint64
abi_route_getNFTAmountLeft:
	// nftType: uint64
	txna ApplicationArgs 2
	btoi

	// eventId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getNFTAmountLeft(uint64,uint64)uint64
	callsub getNFTAmountLeft
	int 1
	return

getNFTAmountLeft:
	proto 2 0

	// if0_condition
	// contracts/nft_marketplace.algo.ts:162
	// nftType === 1
	frame_dig -2 // nftType: uint64
	int 1
	==
	bz if0_end

	// if0_consequent
	// contracts/nft_marketplace.algo.ts:163
	// return this.event(eventId).value.nft1;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 2 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if0_end:
	// if1_condition
	// contracts/nft_marketplace.algo.ts:165
	// nftType === 2
	frame_dig -2 // nftType: uint64
	int 2
	==
	bz if1_end

	// if1_consequent
	// contracts/nft_marketplace.algo.ts:166
	// return this.event(eventId).value.nft2;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 10 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if1_end:
	// if2_condition
	// contracts/nft_marketplace.algo.ts:168
	// nftType === 3
	frame_dig -2 // nftType: uint64
	int 3
	==
	bz if2_end

	// if2_consequent
	// contracts/nft_marketplace.algo.ts:169
	// return this.event(eventId).value.nft3;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 18 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if2_end:
	// contracts/nft_marketplace.algo.ts:171
	// return 0;
	byte 0x151f7c750000000000000000
	log
	retsub

// getNFTPrice(uint64,uint64)uint64
abi_route_getNFTPrice:
	// nftType: uint64
	txna ApplicationArgs 2
	btoi

	// eventId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getNFTPrice(uint64,uint64)uint64
	callsub getNFTPrice
	int 1
	return

getNFTPrice:
	proto 2 0

	// if3_condition
	// contracts/nft_marketplace.algo.ts:175
	// nftType === 1
	frame_dig -2 // nftType: uint64
	int 1
	==
	bz if3_end

	// if3_consequent
	// contracts/nft_marketplace.algo.ts:176
	// return this.event(eventId).value.nft1_price;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 26 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if3_end:
	// if4_condition
	// contracts/nft_marketplace.algo.ts:178
	// nftType === 2
	frame_dig -2 // nftType: uint64
	int 2
	==
	bz if4_end

	// if4_consequent
	// contracts/nft_marketplace.algo.ts:179
	// return this.event(eventId).value.nft2_price;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 34 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if4_end:
	// if5_condition
	// contracts/nft_marketplace.algo.ts:181
	// nftType === 3
	frame_dig -2 // nftType: uint64
	int 3
	==
	bz if5_end

	// if5_consequent
	// contracts/nft_marketplace.algo.ts:182
	// return this.event(eventId).value.nft3_price;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 42 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if5_end:
	// contracts/nft_marketplace.algo.ts:184
	// return 0;
	byte 0x151f7c750000000000000000
	log
	retsub

// getEventByNFT(uint64)uint64
abi_route_getEventByNFT:
	// nftIndex: uint64
	txna ApplicationArgs 1
	btoi

	// execute getEventByNFT(uint64)uint64
	callsub getEventByNFT
	int 1
	return

getEventByNFT:
	proto 1 0

	// contracts/nft_marketplace.algo.ts:188
	// return this.nftDataMap(nftIndex).value.eventId;
	byte 0x6e // "n"
	frame_dig -1 // nftIndex: uint64
	itob
	concat
	box_get
	assert
	extract 0 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getNFTType(uint64)uint64
abi_route_getNFTType:
	// nftIndex: uint64
	txna ApplicationArgs 1
	btoi

	// execute getNFTType(uint64)uint64
	callsub getNFTType
	int 1
	return

getNFTType:
	proto 1 0

	// contracts/nft_marketplace.algo.ts:192
	// return this.nftDataMap(nftIndex).value.nftType;
	byte 0x6e // "n"
	frame_dig -1 // nftIndex: uint64
	itob
	concat
	box_get
	assert
	extract 8 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getNFTAsset(uint64)uint64
abi_route_getNFTAsset:
	// nftIndex: uint64
	txna ApplicationArgs 1
	btoi

	// execute getNFTAsset(uint64)uint64
	callsub getNFTAsset
	int 1
	return

getNFTAsset:
	proto 1 0

	// contracts/nft_marketplace.algo.ts:196
	// return this.nftDataMap(nftIndex).value.nftAsset;
	byte 0x6e // "n"
	frame_dig -1 // nftIndex: uint64
	itob
	concat
	box_get
	assert
	extract 16 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getOrderOwner(uint64)address
abi_route_getOrderOwner:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getOrderOwner(uint64)address
	callsub getOrderOwner
	int 1
	return

getOrderOwner:
	proto 1 0

	// contracts/nft_marketplace.algo.ts:200
	// return this.order(orderId).value.owner;
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 0 32
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getOrderNFT(uint64)uint64
abi_route_getOrderNFT:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getOrderNFT(uint64)uint64
	callsub getOrderNFT
	int 1
	return

getOrderNFT:
	proto 1 0

	// contracts/nft_marketplace.algo.ts:204
	// return this.order(orderId).value.nft;
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 40 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getOrderPrice(uint64)uint64
abi_route_getOrderPrice:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getOrderPrice(uint64)uint64
	callsub getOrderPrice
	int 1
	return

getOrderPrice:
	proto 1 0

	// contracts/nft_marketplace.algo.ts:208
	// return this.order(orderId).value.price;
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 32 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getOrderStatus(uint64)uint64
abi_route_getOrderStatus:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getOrderStatus(uint64)uint64
	callsub getOrderStatus
	int 1
	return

getOrderStatus:
	proto 1 0

	// contracts/nft_marketplace.algo.ts:212
	// return this.order(orderId).value.status;
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 48 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "getApplicationAddress()address"
	method "createEvent(string,uint64,uint64,uint64,uint64,uint64,uint64)void"
	method "mintNFT(string,string)uint64"
	method "mapNFTdata(asset,uint64,uint64)void"
	method "buyNFTFromEvent(pay,asset)void"
	method "listingNFT(asset,uint64,axfer)void"
	method "unListingNFT(uint64,asset)void"
	method "buyNFTFromMarketplace(uint64,pay,asset)void"
	method "getEventName(uint64)string"
	method "getNFTAmountLeft(uint64,uint64)uint64"
	method "getNFTPrice(uint64,uint64)uint64"
	method "getEventByNFT(uint64)uint64"
	method "getNFTType(uint64)uint64"
	method "getNFTAsset(uint64)uint64"
	method "getOrderOwner(uint64)address"
	method "getOrderNFT(uint64)uint64"
	method "getOrderPrice(uint64)uint64"
	method "getOrderStatus(uint64)uint64"
	txna ApplicationArgs 0
	match abi_route_getApplicationAddress abi_route_createEvent abi_route_mintNFT abi_route_mapNFTdata abi_route_buyNFTFromEvent abi_route_listingNFT abi_route_unListingNFT abi_route_buyNFTFromMarketplace abi_route_getEventName abi_route_getNFTAmountLeft abi_route_getNFTPrice abi_route_getEventByNFT abi_route_getNFTType abi_route_getNFTAsset abi_route_getOrderOwner abi_route_getOrderNFT abi_route_getOrderPrice abi_route_getOrderStatus
	err

process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub