#pragma version 9

// This TEAL was generated by TEALScript v0.59.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

// createApplication()void
abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

createApplication:
	proto 0 0

	// contracts/algoticket.algo.ts:46
	// this.eventIndex.value = 0
	byte 0x6576656e74496e646578 // "eventIndex"
	int 0
	app_global_put

	// contracts/algoticket.algo.ts:47
	// this.orderIndex.value = 0
	byte 0x6f72646572496e646578 // "orderIndex"
	int 0
	app_global_put

	// contracts/algoticket.algo.ts:48
	// this.nftIndex.value = 0
	byte 0x6e6674496e646578 // "nftIndex"
	int 0
	app_global_put
	retsub

// createEvent(uint64,uint64,uint64,uint64,uint64,uint64,string)void
abi_route_createEvent:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// nft3price: uint64
	txna ApplicationArgs 7
	btoi

	// nft2price: uint64
	txna ApplicationArgs 6
	btoi

	// nft1price: uint64
	txna ApplicationArgs 5
	btoi

	// nft3: uint64
	txna ApplicationArgs 4
	btoi

	// nft2: uint64
	txna ApplicationArgs 3
	btoi

	// nft1: uint64
	txna ApplicationArgs 2
	btoi

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createEvent(uint64,uint64,uint64,uint64,uint64,uint64,string)void
	callsub createEvent
	int 1
	return

createEvent:
	proto 8 0

	// contracts/algoticket.algo.ts:60
	// temp: eventData = {
	//       name: name,
	//       nft1: nft1,
	//       nft2: nft2,
	//       nft3: nft3,
	//       nft1_price: nft1price,
	//       nft2_price: nft2price,
	//       nft3_price: nft3price,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0032 // initial head offset
	frame_dig -1 // name: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -2 // nft1: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -3 // nft2: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -4 // nft3: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -5 // nft1price: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -6 // nft2price: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -7 // nft3price: uint64
	itob
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury -8 // temp: eventData

	// contracts/algoticket.algo.ts:70
	// this.event(this.eventIndex.value).value = temp
	byte 0x6576656e74496e646578 // "eventIndex"
	app_global_get
	itob
	dup
	box_del
	pop
	frame_dig -8 // temp: eventData
	box_put

	// contracts/algoticket.algo.ts:71
	// this.eventIndex.value = this.eventIndex.value + 1
	byte 0x6576656e74496e646578 // "eventIndex"
	byte 0x6576656e74496e646578 // "eventIndex"
	app_global_get
	int 1
	+
	app_global_put
	retsub

// mintNFT(pay,uint64,uint64,string,string)uint64
abi_route_mintNFT:
	byte 0x; dupn 2 // push empty bytes to fill the stack frame for this subroutine's local variables

	// payment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// nftType: uint64
	txna ApplicationArgs 4
	btoi

	// eventId: uint64
	txna ApplicationArgs 3
	btoi

	// url: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute mintNFT(pay,uint64,uint64,string,string)uint64
	callsub mintNFT
	int 1
	return

mintNFT:
	proto 8 0

	// contracts/algoticket.algo.ts:75
	// nftTicket = sendAssetCreation({
	//       configAssetTotal: 1,
	//       configAssetName: name,
	//       configAssetURL: url,
	//     })
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts/algoticket.algo.ts:76
	// configAssetTotal: 1
	int 1
	itxn_field ConfigAssetTotal

	// contracts/algoticket.algo.ts:77
	// configAssetName: name
	frame_dig -1 // name: bytes
	itxn_field ConfigAssetName

	// contracts/algoticket.algo.ts:78
	// configAssetURL: url
	frame_dig -2 // url: bytes
	itxn_field ConfigAssetURL

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury -6 // nftTicket: asset

	// contracts/algoticket.algo.ts:81
	// this.nft.value = nftTicket
	byte 0x6e6674 // "nft"
	frame_dig -6 // nftTicket: asset
	app_global_put

	// if0_condition
	// contracts/algoticket.algo.ts:84
	// nftType === 1
	frame_dig -4 // nftType: uint64
	int 1
	==
	bz if0_end

	// if0_consequent
	// contracts/algoticket.algo.ts:85
	// assert(this.event(eventId).value.nft1 > 0)
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 2 8
	btoi
	int 0
	>
	assert

	// contracts/algoticket.algo.ts:86
	// this.event(eventId).value.nft1 = this.event(eventId).value.nft1 - 1
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	int 2
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 2 8
	btoi
	int 1
	-
	itob
	replace3
	frame_dig -3 // eventId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put

if0_end:
	// if1_condition
	// contracts/algoticket.algo.ts:88
	// nftType === 2
	frame_dig -4 // nftType: uint64
	int 2
	==
	bz if1_end

	// if1_consequent
	// contracts/algoticket.algo.ts:89
	// assert(this.event(eventId).value.nft2 > 0)
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 10 8
	btoi
	int 0
	>
	assert

	// contracts/algoticket.algo.ts:90
	// this.event(eventId).value.nft2 = this.event(eventId).value.nft2 - 1
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	int 10
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 10 8
	btoi
	int 1
	-
	itob
	replace3
	frame_dig -3 // eventId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put

if1_end:
	// if2_condition
	// contracts/algoticket.algo.ts:92
	// nftType === 3
	frame_dig -4 // nftType: uint64
	int 3
	==
	bz if2_end

	// if2_consequent
	// contracts/algoticket.algo.ts:93
	// assert(this.event(eventId).value.nft3 > 0)
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 18 8
	btoi
	int 0
	>
	assert

	// contracts/algoticket.algo.ts:94
	// this.event(eventId).value.nft3 = this.event(eventId).value.nft3 - 1
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	int 18
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 18 8
	btoi
	int 1
	-
	itob
	replace3
	frame_dig -3 // eventId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put

if2_end:
	// contracts/algoticket.algo.ts:97
	// temp: nftData = {
	//       eventId: eventId,
	//       nftType: nftType,
	//       nftAsset: this.nft.value,
	//     }
	frame_dig -3 // eventId: uint64
	itob
	frame_dig -4 // nftType: uint64
	itob
	concat
	byte 0x6e6674 // "nft"
	app_global_get
	itob
	concat
	frame_bury -7 // temp: nftData

	// contracts/algoticket.algo.ts:103
	// this.nftDataMap(this.nftIndex.value).value = temp
	byte 0x6e // "n"
	byte 0x6e6674496e646578 // "nftIndex"
	app_global_get
	itob
	concat
	frame_dig -7 // temp: nftData
	box_put

	// contracts/algoticket.algo.ts:104
	// this.nftIndex.value = this.nftIndex.value + 1
	byte 0x6e6674496e646578 // "nftIndex"
	byte 0x6e6674496e646578 // "nftIndex"
	app_global_get
	int 1
	+
	app_global_put

	// contracts/algoticket.algo.ts:107
	// price = 0
	int 0
	frame_bury -8 // price: uint64

	// if3_condition
	// contracts/algoticket.algo.ts:108
	// nftType === 1
	frame_dig -4 // nftType: uint64
	int 1
	==
	bz if3_end

	// if3_consequent
	// contracts/algoticket.algo.ts:109
	// price = this.event(eventId).value.nft1_price
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 26 8
	btoi
	frame_bury -8 // price: uint64

if3_end:
	// if4_condition
	// contracts/algoticket.algo.ts:111
	// nftType === 2
	frame_dig -4 // nftType: uint64
	int 2
	==
	bz if4_end

	// if4_consequent
	// contracts/algoticket.algo.ts:112
	// price = this.event(eventId).value.nft2_price
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 34 8
	btoi
	frame_bury -8 // price: uint64

if4_end:
	// if5_condition
	// contracts/algoticket.algo.ts:114
	// nftType === 3
	frame_dig -4 // nftType: uint64
	int 3
	==
	bz if5_end

	// if5_consequent
	// contracts/algoticket.algo.ts:115
	// price = this.event(eventId).value.nft3_price
	frame_dig -3 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 42 8
	btoi
	frame_bury -8 // price: uint64

if5_end:
	// contracts/algoticket.algo.ts:119
	// verifyTxn(payment, {
	//       sender: this.txn.sender,
	//       amount: { greaterThan: price },
	//     })
	// verify sender
	frame_dig -5 // payment: pay
	gtxns Sender
	txn Sender
	==
	assert

	// verify amount
	frame_dig -5 // payment: pay
	gtxns Amount
	frame_dig -8 // price: uint64
	>
	assert

	// contracts/algoticket.algo.ts:125
	// sendAssetTransfer({
	//       xferAsset: this.nft.value,
	//       assetReceiver: this.txn.sender,
	//       assetAmount: 1,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/algoticket.algo.ts:126
	// xferAsset: this.nft.value
	byte 0x6e6674 // "nft"
	app_global_get
	itxn_field XferAsset

	// contracts/algoticket.algo.ts:127
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/algoticket.algo.ts:128
	// assetAmount: 1
	int 1
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/algoticket.algo.ts:130
	// return this.nft.value;
	byte 0x6e6674 // "nft"
	app_global_get
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// listingNFT(axfer,uint64,asset)void
abi_route_listingNFT:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// axfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// price: uint64
	txna ApplicationArgs 2
	btoi

	// nft: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute listingNFT(axfer,uint64,asset)void
	callsub listingNFT
	int 1
	return

listingNFT:
	proto 4 0

	// contracts/algoticket.algo.ts:135
	// verifyTxn(axfer, { assetReceiver: this.app.address })
	// verify assetReceiver
	frame_dig -3 // axfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/algoticket.algo.ts:138
	// temp: orderData = {
	//       owner: this.txn.sender,
	//       price: price,
	//       nft: nft,
	//       status: 0,
	//     }
	txn Sender
	frame_dig -2 // price: uint64
	itob
	concat
	frame_dig -1 // nft: asset
	itob
	concat
	byte 0x0000000000000000
	concat
	frame_bury -4 // temp: orderData

	// contracts/algoticket.algo.ts:145
	// this.order(this.orderIndex.value).value = temp
	byte 0x6f // "o"
	byte 0x6f72646572496e646578 // "orderIndex"
	app_global_get
	itob
	concat
	frame_dig -4 // temp: orderData
	box_put

	// contracts/algoticket.algo.ts:146
	// this.orderIndex.value = this.orderIndex.value + 1
	byte 0x6f72646572496e646578 // "orderIndex"
	byte 0x6f72646572496e646578 // "orderIndex"
	app_global_get
	int 1
	+
	app_global_put
	retsub

// unListingNFT(uint64)void
abi_route_unListingNFT:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute unListingNFT(uint64)void
	callsub unListingNFT
	int 1
	return

unListingNFT:
	proto 1 0

	// contracts/algoticket.algo.ts:151
	// assert(this.txn.sender === this.order(orderId).value.owner)
	txn Sender
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 0 32
	==
	assert

	// contracts/algoticket.algo.ts:154
	// assert(this.order(orderId).value.status === 1)
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 48 8
	btoi
	int 1
	==
	assert

	// contracts/algoticket.algo.ts:156
	// this.order(orderId).value.status = 1
	int 48
	byte 0x0000000000000001
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/algoticket.algo.ts:159
	// sendAssetTransfer({
	//       xferAsset: this.order(orderId).value.nft,
	//       assetReceiver: this.txn.sender,
	//       assetAmount: 1,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/algoticket.algo.ts:160
	// xferAsset: this.order(orderId).value.nft
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 40 8
	btoi
	itxn_field XferAsset

	// contracts/algoticket.algo.ts:161
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/algoticket.algo.ts:162
	// assetAmount: 1
	int 1
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// buyNFT(pay,uint64)void
abi_route_buyNFT:
	// payment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute buyNFT(pay,uint64)void
	callsub buyNFT
	int 1
	return

buyNFT:
	proto 2 0

	// contracts/algoticket.algo.ts:168
	// assert(this.order(orderId).value.status === 0)
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 48 8
	btoi
	int 0
	==
	assert

	// contracts/algoticket.algo.ts:170
	// verifyTxn(payment, {
	//       sender: this.txn.sender,
	//       amount: { greaterThan: this.order(orderId).value.price },
	//       receiver: this.order(orderId).value.owner,
	//     })
	// verify sender
	frame_dig -2 // payment: pay
	gtxns Sender
	txn Sender
	==
	assert

	// verify amount
	frame_dig -2 // payment: pay
	gtxns Amount
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 32 8
	btoi
	>
	assert

	// verify receiver
	frame_dig -2 // payment: pay
	gtxns Receiver
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 0 32
	==
	assert

	// contracts/algoticket.algo.ts:177
	// sendAssetTransfer({
	//       xferAsset: this.order(orderId).value.nft,
	//       assetReceiver: this.txn.sender,
	//       assetAmount: 1,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/algoticket.algo.ts:178
	// xferAsset: this.order(orderId).value.nft
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 40 8
	btoi
	itxn_field XferAsset

	// contracts/algoticket.algo.ts:179
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/algoticket.algo.ts:180
	// assetAmount: 1
	int 1
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// getEventName(uint64)string
abi_route_getEventName:
	// eventId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getEventName(uint64)string
	callsub getEventName
	int 1
	return

getEventName:
	proto 1 0

	// contracts/algoticket.algo.ts:185
	// return this.event(eventId).value.name;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	int 0
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getNFTAmountLeft(uint64,uint64)uint64
abi_route_getNFTAmountLeft:
	// nftType: uint64
	txna ApplicationArgs 2
	btoi

	// eventId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getNFTAmountLeft(uint64,uint64)uint64
	callsub getNFTAmountLeft
	int 1
	return

getNFTAmountLeft:
	proto 2 0

	// if6_condition
	// contracts/algoticket.algo.ts:189
	// nftType === 1
	frame_dig -2 // nftType: uint64
	int 1
	==
	bz if6_end

	// if6_consequent
	// contracts/algoticket.algo.ts:190
	// return this.event(eventId).value.nft1;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 2 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if6_end:
	// if7_condition
	// contracts/algoticket.algo.ts:192
	// nftType === 2
	frame_dig -2 // nftType: uint64
	int 2
	==
	bz if7_end

	// if7_consequent
	// contracts/algoticket.algo.ts:193
	// return this.event(eventId).value.nft2;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 10 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if7_end:
	// if8_condition
	// contracts/algoticket.algo.ts:195
	// nftType === 3
	frame_dig -2 // nftType: uint64
	int 3
	==
	bz if8_end

	// if8_consequent
	// contracts/algoticket.algo.ts:196
	// return this.event(eventId).value.nft3;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 18 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if8_end:
	// contracts/algoticket.algo.ts:198
	// return 0;
	byte 0x151f7c750000000000000000
	log
	retsub

// getNFTPrice(uint64,uint64)uint64
abi_route_getNFTPrice:
	// nftType: uint64
	txna ApplicationArgs 2
	btoi

	// eventId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getNFTPrice(uint64,uint64)uint64
	callsub getNFTPrice
	int 1
	return

getNFTPrice:
	proto 2 0

	// if9_condition
	// contracts/algoticket.algo.ts:202
	// nftType === 1
	frame_dig -2 // nftType: uint64
	int 1
	==
	bz if9_end

	// if9_consequent
	// contracts/algoticket.algo.ts:203
	// return this.event(eventId).value.nft1_price;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 26 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if9_end:
	// if10_condition
	// contracts/algoticket.algo.ts:205
	// nftType === 2
	frame_dig -2 // nftType: uint64
	int 2
	==
	bz if10_end

	// if10_consequent
	// contracts/algoticket.algo.ts:206
	// return this.event(eventId).value.nft2_price;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 34 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if10_end:
	// if11_condition
	// contracts/algoticket.algo.ts:208
	// nftType === 3
	frame_dig -2 // nftType: uint64
	int 3
	==
	bz if11_end

	// if11_consequent
	// contracts/algoticket.algo.ts:209
	// return this.event(eventId).value.nft3_price;
	frame_dig -1 // eventId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 42 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if11_end:
	// contracts/algoticket.algo.ts:211
	// return 0;
	byte 0x151f7c750000000000000000
	log
	retsub

// getEventByNFT(uint64)uint64
abi_route_getEventByNFT:
	// nftIndex: uint64
	txna ApplicationArgs 1
	btoi

	// execute getEventByNFT(uint64)uint64
	callsub getEventByNFT
	int 1
	return

getEventByNFT:
	proto 1 0

	// contracts/algoticket.algo.ts:215
	// return this.nftDataMap(nftIndex).value.eventId;
	byte 0x6e // "n"
	frame_dig -1 // nftIndex: uint64
	itob
	concat
	box_get
	assert
	extract 0 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getNFTType(uint64)uint64
abi_route_getNFTType:
	// nftIndex: uint64
	txna ApplicationArgs 1
	btoi

	// execute getNFTType(uint64)uint64
	callsub getNFTType
	int 1
	return

getNFTType:
	proto 1 0

	// contracts/algoticket.algo.ts:219
	// return this.nftDataMap(nftIndex).value.nftType;
	byte 0x6e // "n"
	frame_dig -1 // nftIndex: uint64
	itob
	concat
	box_get
	assert
	extract 8 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getNFTAsset(uint64)uint64
abi_route_getNFTAsset:
	// nftIndex: uint64
	txna ApplicationArgs 1
	btoi

	// execute getNFTAsset(uint64)uint64
	callsub getNFTAsset
	int 1
	return

getNFTAsset:
	proto 1 0

	// contracts/algoticket.algo.ts:223
	// return this.nftDataMap(nftIndex).value.nftAsset;
	byte 0x6e // "n"
	frame_dig -1 // nftIndex: uint64
	itob
	concat
	box_get
	assert
	extract 16 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getOrderOwner(uint64)address
abi_route_getOrderOwner:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getOrderOwner(uint64)address
	callsub getOrderOwner
	int 1
	return

getOrderOwner:
	proto 1 0

	// contracts/algoticket.algo.ts:227
	// return this.order(orderId).value.owner;
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 0 32
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getOrderNFT(uint64)uint64
abi_route_getOrderNFT:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getOrderNFT(uint64)uint64
	callsub getOrderNFT
	int 1
	return

getOrderNFT:
	proto 1 0

	// contracts/algoticket.algo.ts:231
	// return this.order(orderId).value.nft;
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 40 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getOrderPrice(uint64)uint64
abi_route_getOrderPrice:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getOrderPrice(uint64)uint64
	callsub getOrderPrice
	int 1
	return

getOrderPrice:
	proto 1 0

	// contracts/algoticket.algo.ts:235
	// return this.order(orderId).value.price;
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 32 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getOrderStatus(uint64)uint64
abi_route_getOrderStatus:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getOrderStatus(uint64)uint64
	callsub getOrderStatus
	int 1
	return

getOrderStatus:
	proto 1 0

	// contracts/algoticket.algo.ts:239
	// return this.order(orderId).value.status;
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 48 8
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "createEvent(string,uint64,uint64,uint64,uint64,uint64,uint64)void"
	method "mintNFT(string,string,uint64,uint64,pay)uint64"
	method "listingNFT(asset,uint64,axfer)void"
	method "unListingNFT(uint64)void"
	method "buyNFT(uint64,pay)void"
	method "getEventName(uint64)string"
	method "getNFTAmountLeft(uint64,uint64)uint64"
	method "getNFTPrice(uint64,uint64)uint64"
	method "getEventByNFT(uint64)uint64"
	method "getNFTType(uint64)uint64"
	method "getNFTAsset(uint64)uint64"
	method "getOrderOwner(uint64)address"
	method "getOrderNFT(uint64)uint64"
	method "getOrderPrice(uint64)uint64"
	method "getOrderStatus(uint64)uint64"
	txna ApplicationArgs 0
	match abi_route_createEvent abi_route_mintNFT abi_route_listingNFT abi_route_unListingNFT abi_route_buyNFT abi_route_getEventName abi_route_getNFTAmountLeft abi_route_getNFTPrice abi_route_getEventByNFT abi_route_getNFTType abi_route_getNFTAsset abi_route_getOrderOwner abi_route_getOrderNFT abi_route_getOrderPrice abi_route_getOrderStatus
	err

process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub